/**
 *  
 */

"use strict";
const mmtAdaptor  = require('../libs/dataAdaptor');
const config      = require('../libs/config');
const ip2loc      = require('../libs/ip2loc');
const DataBase    = require("./DataBase.js");
const COL         = mmtAdaptor.StatsColumnId;
const s1apTopo    = require("./EnodebTopo");

//DONOT remove this block
//this is for sending data to web clients vi socketio
var caches = {};
function saveToDatabase( channel, msg ){
	if( caches[ channel ] === undefined )
		caches[ channel ] = [];
	//add msg to caches
	//caches will be verified each seconds and sent to client
	//caches[ channel ].push( msg );
}

function _saveToDB( collectionName, dataArr ){
   inserterDB.set( collectionName, 0, dataArr );
}

setInterval( function(){
	for( const channel in caches ){
		const cache = caches[ channel ];
		//no data in this cache
		if( cache.length === 0 )
			continue;
		//avg
		if (channel === "qos" ){
			for( let j=1; j<cache.length; j++)
				for( let i=4; i<13;i++ )
					cache[0][i] += cache[j][i];

			for( let i=4; i<13;i++ )
				if( i !== 9 || i !== 10 )
					cache[0][i] /= cache.length;

			//router.socketio.emit( "qos", cache[0] );
		}else {
		   //broadcast a message to Web browsers using socketio
		   _saveToDB( "cache_" + channel, cache );
		}

		//reset this cache to zero
		caches[ channel ] = [];
	}
}, 1000);
//end caches


/**
 * Compare two versions strings
 * @param a
 * @param b
 * @returns 
 *   1 if a > b
 *  -1 if a < b
 *   0 if a = b
 */
function compareVersion(a, b)
{
    //treat non-numerical characters as lover version
    //replacing them with a negative number based on charcode of each character
    function fix(s)
    {
        return "." + (s.toLowerCase().charCodeAt(0) - 2147483647) + ".";
    }
    a = ("" + a).replace(/[^0-9\.]/g, fix).split('.');
    b = ("" + b).replace(/[^0-9\.]/g, fix).split('.');
    var c = Math.max(a.length, b.length);
    for (var i = 0; i < c; i++)
    {
        //convert to integer the most efficient way
        a[i] = ~~a[i];
        b[i] = ~~b[i];
        if (a[i] > b[i])
            return 1;
        else if (a[i] < b[i])
            return -1;
    }
    return 0;
}

const operatorVersion = require('../version.json');
function checkVersion( probeVersion ){
   //operatorVersion >= 1.6.12  <=> probeVersion >= 1.4.1
   const ov = (compareVersion(operatorVersion.VERSION_NUMBER, '1.6.12') >= 0 );
   const op = ( compareVersion( probeVersion, '1.4.1') >= 0); 
   //check ov <=> op
   if( (ov && !op) || (!ov && op )){
      console.error('This MMT-Operator does not support MMT-Probe version ' + probeVersion );
      return false;
   }
   
   
   
   return true;
}



function ProcessMessage( database ){
	const self       = this;
	const _database  = database; 
	
	let isCompatibleVersion = {};
	
	/**
	 * Process a message report generated by MMT-Probe:
	 * 	- insert the message to DB
	 *  - send it directly to Web client if need
	 * @param message
	 * @returns
	 */
	self.process = function( message ) {
	   
	   
		//console.log( message );
		//message = message.replace(/\(null\)/g, 'null');
		var msg;
		//report is a JSON array ???
		if( message.charAt(0) == '[' ){
		} else //report is a CSV line
		   message = '[' + message + ']';

      msg = mmtAdaptor.formatMessage( message );
		if( msg === null )
			return;
		
		const probeId = msg[1];
      
		//For each kind of message
		switch( msg[0] ){
	   case mmtAdaptor.CsvFormat.SESSION_STATS_FORMAT:
	      break;
		/*
        case mmtAdaptor.CsvFormat.NO_SESSION_STATS_FORMAT:
            if( config.only_ip_session === true ){
                //console.log( message );
                return;
            }
            break;
		 */
			//does not use these kind of reports
			/*
		case mmtAdaptor.CsvFormat.DEFAULT_APP_FORMAT:
		case mmtAdaptor.CsvFormat.WEB_APP_FORMAT:
		case mmtAdaptor.CsvFormat.SSL_APP_FORMAT:
			return;
			 */

			//behaviour: changing bandwidth
//		case mmtAdaptor.CsvFormat.BA_BANDWIDTH_FORMAT:
//			break;
//		case mmtAdaptor.CsvFormat.BA_PROFILE_FORMAT:
//			break;

			//license information
//		case mmtAdaptor.CsvFormat.LICENSE:
//			//if( typeof databaseadmin )
//			//	databaseadmin.insertLicense( mmtAdaptor.formatReportItem( msg ));
//			break;
		//report is sent only once when starting up	
		case mmtAdaptor.CsvFormat.STARTUP_REPORT:
		   //msg = [1,3,"a.pcap",1561454264.093644,"1.4.1 (da0638f - Jun 21 2019 11:59:18)","1.6.14.2 (2a482da)"]
		   //check if version of mmt-probe is satisfied
		   let probeVersion = msg[4]; //1.4.1 (da0638f - Jun 21 2019 11:59:18)
		   probeVersion = probeVersion.split(' ')[0]; //1.4.1
		   
		   console.log("Checking mmt-probe " + probeVersion + " having id=" + probeId);
		   isCompatibleVersion[ probeId ] = checkVersion( probeVersion );
		   
		   
		   //we need to reset enodeb topology
		   if( isCompatibleVersion[ probeId ] )
		       s1apTopo.resetTopology( msg );
		   
		   break;

		case mmtAdaptor.CsvFormat.LTE_TOPOLOGY_REPORT:
		   s1apTopo.processMessage( msg );
		   break;
		   
			//Video QoS
		case mmtAdaptor.CsvFormat.OTT_QOS:
			//send_to_client( "qos", msg );
			break;
			//Security alerts
		case mmtAdaptor.CsvFormat.SECURITY_FORMAT:
			//send_to_client( "security", msg );
			break;
			//availability
		//case 50:
		//   console.info( msg );
		}

		//TODO: to be remove, this chages probe ID, only for Thales demo
		//msg[1] = "Sodium";

		//to test mult-probe
		//msg[1] = Math.random() > 0.5 ? 1 : 0;

		if( isCompatibleVersion[probeId] === false ){
         console.warn('This mmt-operator does not support data format of the mmt-probe ' + probeId + '. The message will be ignored.');
         return;
      }
		
		//_TODO: re-enable this
		_database.add(msg, function (err, err_msg) {});
		msg = null;
	};
}

module.exports = ProcessMessage;