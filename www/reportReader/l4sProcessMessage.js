const ip2loc      = require("../libs/ip2loc");
const config      = require("../libs/config");
const dataAdaptor = require('../libs/dataAdaptor');
const COL         = dataAdaptor.StatsColumnId
const SEC         = dataAdaptor.SecurityColumnId;
const L4S_REPORT = {
	//event-based report format: https://github.com/Montimage/mmt-probe/blob/master/docs/data-format.md#event-report
	"int.hop_queue_ids"     : 5,
	"meta.packet_len"       : 6,
	"meta.proto_hierarchy"  : 7,
	"ethernet.src"          : 8,
	"ethernet.dst"          : 9,
	"ip.src"                : 10, 
	"ip.dst"                : 11, 
	"udp.src_port"          : 12,
	"udp.dest_port"         : 13,
	"tcp.src_port"          : 14,
	"tcp.dest_port"         : 15,
	"ip.ecn"                : 16,
	"quic_ietf.spin_bit"    : 17,
	"quic_ietf.rtt"         : 18,
	"int.hop_latencies"     : 19, 
	"int.hop_queue_occups"  : 20,
	"int.hop_ingress_times" : 21, 
	"int.hop_egress_times"  : 22,
	"int.hop_l4s_mark"      : 23, 
	"int.hop_l4s_drop"      : 24,
	"int.hop_tx_utilizes"   : 25
}

const isEnable = !!( Array.isArray(config.modules) && (config.modules.indexOf("l4s") > -1) )

console.info("Module L4S is " + (isEnable? "enabled": "disabled"))

let last_alert_ts = 0;

module.exports = {
	isEnable: isEnable,
	//convert event-based report to session report
/*
L4S reports are generated by event-based reports
event-report l4s {
	enable = true
	event  =  "int.hop_queue_ids"
	attributes = { 
	"meta.packet_len",
	"meta.proto_hierarchy",
	"ethernet.src",
	"ethernet.dst",
	"ip.client_addr", 
	"ip.server_addr", 
	"ip.client_port",
	"ip.server_port",
	"ip.ecn",
	"quic_ietf.spin_bit",
	"quic_ietf.rtt",
	"int.hop_latencies", 
	"int.hop_queue_occups",
	"int.hop_ingress_times", 
	"int.hop_egress_times",
	"int.hop_l4s_mark", 
	"int.hop_l4s_drop",
	"int.hop_tx_utilizes" #mark proba
	}
	output-channel = {socket}
}
 Example:
1000,3,"l4s-mon-nic-int.pcap",1689789772.961998,"l4s",1,1350,"99.178.376.658.661","24:6e:96:37:81:a8","08:00:27:09:27:51","10.0.0.13","10.0.1.13",45422,3000,1,0,133123,123,0,148723952000,148724075000,0,0,2028585516

=> we will transform this kind of reports to IP session reports 
   to be able to reuse some existing dashboards, such as, Link, Network, DPI
*/

	processMessage: function( msg ){
		const newMsg = [];
		for( let i in COL )
			newMsg[i] = "";

		newMsg[COL.FORMAT_ID]      = dataAdaptor.CsvFormat.SESSION_STATS_FORMAT;
		//keep these values
		newMsg[COL.PROBE_ID]       = msg[COL.PROBE_ID];
		newMsg[COL.SOURCE_ID]      = msg[COL.SOURCE_ID];
		newMsg[COL.TIMESTAMP]      = msg[COL.TIMESTAMP];
		
		newMsg[COL.START_TIME]     = msg[COL.TIMESTAMP];

		newMsg[COL.APP_PATH]       = msg[ L4S_REPORT["meta.proto_hierarchy"] ];
		newMsg[COL.APP_ID]         = dataAdaptor.getAppIdFromPath( newMsg[COL.APP_PATH] );
		newMsg[COL.PROFILE_ID ]    = dataAdaptor.getCategoryIdFromAppId( newMsg[COL.APP_ID] );
		
		newMsg[COL.IP_SRC]         = msg[ L4S_REPORT["ip.src"] ];
		newMsg[COL.IP_DST]         = msg[ L4S_REPORT["ip.dst"] ];

		//if protocol path contain IP.UDP
		if( newMsg[COL.APP_PATH].indexOf(".178.376.") ){
			newMsg[COL.PORT_SRC]    = msg[ L4S_REPORT["udp.src_port"] ];
			newMsg[COL.PORT_DST]    = msg[ L4S_REPORT["udp.dest_port"] ];
		} else {
			newMsg[COL.PORT_SRC]    = msg[ L4S_REPORT["tcp.src_port"] ];
			newMsg[COL.PORT_DST]    = msg[ L4S_REPORT["tcp.dest_port"] ];
		}

		newMsg[COL.SRC_LOCATION]   = ip2loc.country( newMsg[COL.IP_SRC] );
		newMsg[COL.DST_LOCATION]   = ip2loc.country( newMsg[COL.IP_DST] );
		
		newMsg[COL.MAC_SRC]        = msg[ L4S_REPORT["ethernet.src"] ];
		newMsg[COL.MAC_DST]        = msg[ L4S_REPORT["ethernet.dst"] ];
		
		newMsg[COL.DATA_VOLUME]    = newMsg[COL.UL_DATA_VOLUME]  =  msg[ L4S_REPORT["meta.packet_len"] ];
		newMsg[COL.PACKET_COUNT]   = newMsg[COL.UL_PACKET_COUNT] = 1; //only one packet per report
		
		newMsg[COL.HANDSHAKE_TIME] = msg[L4S_REPORT["quic_ietf.rtt"]]
		
		newMsg[COL.L4S_QUEUE_ID]     = msg[L4S_REPORT["int.hop_queue_ids"]]
		newMsg[COL.L4S_HOP_LATENCY]  = msg[L4S_REPORT["int.hop_latencies"]]
		newMsg[COL.L4S_QUEUE_OCCUPS] = msg[L4S_REPORT["int.hop_queue_occups"]]
		newMsg[COL.L4S_NB_MARK]      = msg[L4S_REPORT["int.hop_l4s_mark"]]
		newMsg[COL.L4S_NB_DROP]      = msg[L4S_REPORT["int.hop_l4s_drop"]]
		newMsg[COL.L4S_MARK_PROBAB]  = Math.round(msg[L4S_REPORT["int.hop_tx_utilizes"]] * 100 / 0xFFFFFFFF); //percentage
		return newMsg;
	},
	
	//simulate an attack detection
	getDummyAlert: function( msg ){
		const src = config.modules_config.l4s.server.attack_source;
		//console.log( src, JSON.stringify( msg ));
		if( msg[COL.IP_SRC] != src.ip || msg[COL.PORT_SRC] != src.port )
			return
		
		const now = msg[COL.TIMESTAMP];
		
		//at most one alert per minute
		if( now - last_alert_ts < 60*1000 )
			return;
		
		last_alert_ts = now;
		
		//create a dummy alert
		const alertMsg = [];
		//https://github.com/Montimage/mmt-probe/blob/master/docs/data-format.md#security-reports
		alertMsg[COL.FORMAT_ID]      = dataAdaptor.CsvFormat.SECURITY_FORMAT;
		//keep these values
		alertMsg[COL.PROBE_ID]       = msg[COL.PROBE_ID];
		alertMsg[COL.SOURCE_ID]      = msg[COL.SOURCE_ID];
		alertMsg[COL.TIMESTAMP]      = msg[COL.TIMESTAMP];
		
		alertMsg[SEC.PROPERTY]       = 10;
		alertMsg[SEC.VERDICT]        = "detected",
		alertMsg[SEC.TYPE]           = "attack",
		alertMsg[SEC.DESCRIPTION]     = src.description,
		alertMsg[SEC.HISTORY]        = {"event_1": {"timestamp": now/1000 /* back to format second.microsecond*/, "description": "", "attributes":[["ip.src",src.ip], ["ip.port_src", src.port]] }};
		console.log("Generated a dummy L4S alert", JSON.stringify(alertMsg));
		return alertMsg;
	}
}