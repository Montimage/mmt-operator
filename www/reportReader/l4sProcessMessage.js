const ip2loc      = require("../libs/ip2loc");
const dataAdaptor = require('../libs/dataAdaptor');
const COL         = dataAdaptor.StatsColumnId

const L4S_REPORT = {
	//event-based report format: https://github.com/Montimage/mmt-probe/blob/master/docs/data-format.md#event-report
	"int.hop_queue_ids"     : 5,
	"meta.packet_len"       : 6,
	"meta.proto_hierarchy"  : 7,
	"ethernet.src"          : 8,
	"ethernet.dst"          : 9,
	"ip.client_addr"        : 10, 
	"ip.server_addr"        : 11, 
	"ip.client_port"        : 12,
	"ip.server_port"        : 13,
	"ip.ecn"                : 14,
	"quic_ietf.spin_bit"    : 15,
	"quic_ietf.rtt"         : 16,
	"int.hop_latencies"     : 17, 
	"int.hop_queue_occups"  : 18,
	"int.hop_ingress_times" : 19, 
	"int.hop_egress_times"  : 20,
	"int.hop_l4s_mark"      : 21, 
	"int.hop_l4s_drop"      : 22,
	"int.hop_tx_utilizes"   : 23
}

module.exports = {
	//convert event-based report to session report
/*
L4S reports are generated by event-based reports
event-report l4s {
	enable = true
	event  =  "int.hop_queue_ids"
	attributes = { 
	"meta.packet_len",
	"meta.proto_hierarchy",
	"ethernet.src",
	"ethernet.dst",
	"ip.client_addr", 
	"ip.server_addr", 
	"ip.client_port",
	"ip.server_port",
	"ip.ecn",
	"quic_ietf.spin_bit",
	"quic_ietf.rtt",
	"int.hop_latencies", 
	"int.hop_queue_occups",
	"int.hop_ingress_times", 
	"int.hop_egress_times",
	"int.hop_l4s_mark", 
	"int.hop_l4s_drop",
	"int.hop_tx_utilizes" #mark proba
	}
	output-channel = {socket}
}
 Example:
1000,3,"l4s-mon-nic-int.pcap",1689789772.961998,"l4s",1,1350,"99.178.376.658.661","24:6e:96:37:81:a8","08:00:27:09:27:51","10.0.0.13","10.0.1.13",45422,3000,1,0,133123,123,0,148723952000,148724075000,0,0,2028585516

=> we will transform this kind of reports to IP session reports 
   to be able to reuse some existing dashboards, such as, Link, Network, DPI
*/

	processMessage: function( msg ){
		const newMsg = [];
		for( let i in COL )
			newMsg[i] = "";

		newMsg[COL.FORMAT_ID]      = dataAdaptor.CsvFormat.SESSION_STATS_FORMAT;
		//keep these values
		newMsg[COL.PROBE_ID]       = msg[COL.PROBE_ID];
		newMsg[COL.SOURCE_ID]      = msg[COL.SOURCE_ID];
		newMsg[COL.TIMESTAMP]      = msg[COL.TIMESTAMP];
		
		newMsg[COL.START_TIME]     = msg[COL.TIMESTAMP];

		newMsg[COL.APP_PATH]       = msg[ L4S_REPORT["meta.proto_hierarchy"] ];
		newMsg[COL.APP_ID]         = dataAdaptor.getAppIdFromPath( newMsg[COL.APP_PATH] );
		newMsg[COL.PROFILE_ID ]    = dataAdaptor.getCategoryIdFromAppId( newMsg[COL.APP_ID] );
		
		newMsg[COL.IP_SRC]         = msg[ L4S_REPORT["ip.client_addr"] ];
		newMsg[COL.IP_DST]         = msg[ L4S_REPORT["ip.server_addr"] ];
		newMsg[COL.PORT_SRC]       = msg[ L4S_REPORT["ip.client_port"] ];
		newMsg[COL.PORT_DST]       = msg[ L4S_REPORT["ip.server_port"] ];
		newMsg[COL.SRC_LOCATION]   = ip2loc.country( newMsg[COL.IP_SRC] );
		newMsg[COL.DST_LOCATION]   = ip2loc.country( newMsg[COL.IP_DST] );
		
		newMsg[COL.MAC_SRC]        = msg[ L4S_REPORT["ethernet.src"] ];
		newMsg[COL.MAC_DST]        = msg[ L4S_REPORT["ethernet.dst"] ];
		
		newMsg[COL.DATA_VOLUME]    = newMsg[COL.UL_DATA_VOLUME]  =  msg[ L4S_REPORT["meta.packet_len"] ];
		newMsg[COL.PACKET_COUNT]   = newMsg[COL.UL_PACKET_COUNT] = 1; //only one packet per report
		
		newMsg[COL.HANDSHAKE_TIME] = msg[L4S_REPORT["quic_ietf.rtt"]]
		
		return newMsg;
	}
}