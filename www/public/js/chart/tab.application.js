var arr = [
    {
        id: "response_time",
        title: "Transaction Time",
        x: 0,
        y: 0,
        width: 12,
        height: 9,
        type: "success",
        userData: {
            fn: "createResponseTimeReport"
        },
    },
    {
        id: "top_local",
        title: "Top Users",
        x: 0,
        y: 0,
        width: 4,
        height: 4,
        type: "success",
        userData: {
            fn: "createSlowestLocalsReport"
        },
    },{
        id: "top_app",
        title: "Top Applications",
        x: 4,
        y: 0,
        width: 4,
        height: 4,
        type: "success",
        userData: {
            fn: "createSlowestAppsReport"
        },
    },{
        id: "top_remote",
        title: "Top Remotes",
        x: 8,
        y: 0,
        width: 4,
        height: 4,
        type: "success",
        userData: {
            fn: "createSlowestRemotesReport"
        },
    },
];

var availableReports = {
    "createResponseTimeReport": "Response Time",
};

if( URL_PARAM.app == "All")
  delete( URL_PARAM.app );

if( URL_PARAM.app && URL_PARAM.ip && URL_PARAM.remote && URL_PARAM.ts && URL_PARAM.groupby )
  MMTDrop.tools.gotoURL( MMTDrop.tools.getCurrentURL().replace(/application/, "application/detail") );

URL_PARAM.app_id = function(){
  if( URL_PARAM._app_id != undefined )
    return URL_PARAM._app_id;

  URL_PARAM._app_id = MMTDrop.constants.getProtocolIDFromName( URL_PARAM.app );
  return URL_PARAM._app_id;
}

//select only TCP-based app
const APP_PATH_REGEX = {"$regex" : ".354.", "$options" : ""};
//create reports
var ReportFactory = {
    formatTime : function( date ){
          return moment( date.getTime() ).format( fPeriod.getTimeFormat() );
    },

    formatRTT : function( time ){
        return (time/1000).toFixed( 2 );
    },
    divide : function( a, b ){
      if (b == 0) return a;
      //equivalent with toFixed(2) but return a number (instanceof string)
      return Math.round( a * 100/b )/100;
    },

    createResponseTimeReport: function (fPeriod) {
        var _this = this;
        var COL   = MMTDrop.constants.StatsColumn;
        var FTP   = MMTDrop.constants.FtpStatsColumn;

        var fApp  = MMTDrop.filterFactory.createAppFilter();
        fApp.onFilter( function( opt ){
          MMTDrop.tools.gotoURL( MMTDrop.tools.getCurrentURL([], "app=" + opt.label) );
        });

        var appList_db = MMTDrop.databaseFactory.createStatDB(
          {collection: "data_session", action: "aggregate"}
        );
        appList_db._reload = function(){
          var group = { _id : {} };
          [COL.APP_ID.id ].forEach( function( el, index){
            group["_id"][ el ] = "$" + el;
          } );
          [COL.APP_ID.id, COL.APP_PATH.id].forEach( function( el, index){
            group[ el ] = {"$first" : "$"+ el};
          } );

          var $match = {isGen: false}; //select only App given by probe
          // (not apps generated by mmt-opertor:
          // eg, when probe gives ETH.IP.TCP.HTTP, mmt-opertor will generates an entry for ETH, another for IP, and another for TCP)

          //select only proto/app based on IP
          $match[ COL.FORMAT_ID.id ] = MMTDrop.constants.CsvFormat.STATS_FORMAT;

          //timestamp
          var period = status_db.time; //this comes from common.js
          $match[ COL.TIMESTAMP.id ]  = {$gte: period.begin, $lte: period.end };

          //select only proto/app based on TCP : 354
          $match[ COL.APP_PATH.id ]  = APP_PATH_REGEX;

          appList_db.reload( {query: [{"$match": $match}, {"$group" : group}],
                               period_groupby: fPeriod.selectedOption().id},
            function( new_data, f ){
              var obj = {};
              for( var i in new_data ){
                var id    = new_data[i][ COL.APP_ID.id ];
                obj[ id ] = MMTDrop.constants.getProtocolNameFromID( id );
              }
              var arr = [];
              for( i in obj )
                if (obj[i] == URL_PARAM.app)
                  arr.push( {id: i, label : obj[i], selected : true} );
                else
                  arr.push( {id: i, label : obj[i]} );

                if( arr.length > 1 )
                  if( URL_PARAM.app == undefined )
                    arr.unshift({ id: 0, label: "All", selected : true });
                  else
                    arr.unshift({ id: 0, label: "All" });

                f.option( arr );
                f.redraw();
              //f.attachTo( appList_db );
              //f.filter();
            }, fApp );
        }//end appList_db._reload



        var database = new MMTDrop.Database( {collection: "data_session", action: "aggregate", raw:true,
                        no_override_when_reload: true, period_groupby: fPeriod.selectedOption().id },
          //this function is called when database got data from server
          function( data ){
            //reload list of app/proto
            appList_db._reload();

            //group by timestamp
            var cols = [ COL.DATA_VOLUME, COL.PAYLOAD_VOLUME, COL.PACKET_COUNT, COL.ACTIVE_FLOWS,
               COL.HANDSHAKE_TIME, COL.DATA_TRANSFER_TIME, COL.APP_RESPONSE_TIME,
               COL.UL_RETRANSMISSION, COL.DL_RETRANSMISSION ];

            //sort by inc of time
            data.sort( function( a, b){
                return a[ COL.TIMESTAMP.id ] - b[ COL.TIMESTAMP.id ];
            })

            var time_interval = fPeriod.getDistanceBetweenToSamples();
            //format data
            for( var i=0; i<data.length; i++ ){
              //add index
              data[i][0] = i+1;
              //avg of 1 session
              var val = data[i][ COL.ACTIVE_FLOWS.id ] * 1000; //micro second => milli second
              data[i][ COL.HANDSHAKE_TIME.id ]     = _this.divide( data[i][ COL.HANDSHAKE_TIME.id ], val);
              data[i][ COL.DATA_TRANSFER_TIME.id ] = _this.divide( data[i][ COL.DATA_TRANSFER_TIME.id ], val);
              data[i][ COL.APP_RESPONSE_TIME.id ]  = _this.divide( data[i][ COL.APP_RESPONSE_TIME.id ] , val);


              //% of retransmision
              data[i][ COL.DL_RETRANSMISSION.id ] = _this.divide( (data[i][ COL.DL_RETRANSMISSION.id ] + data[i][COL.UL_RETRANSMISSION]) *100, data[i][ COL.PACKET_COUNT.id ] );
              //% of payload
              data[i][ COL.PAYLOAD_VOLUME.id ] = _this.divide( data[i][ COL.PAYLOAD_VOLUME.id ]*100, data[i][ COL.DATA_VOLUME.id ] );
              //bit per second
              data[i][ COL.DATA_VOLUME.id ]    = _this.divide( data[i][ COL.DATA_VOLUME.id ]*8, time_interval );
              //pps
              data[i][ COL.PACKET_COUNT.id ]   = _this.divide( data[i][ COL.PACKET_COUNT.id ], time_interval );
            }


            //add zero points for the timestamp that have no data
            var start_time = status_db.time.begin,
                end_time   = status_db.time.end,
                period_sampling = fPeriod.getDistanceBetweenToSamples() * 1000,
                time_id = 3;

            //check whenever probe runing at the moment ts
            var inActivePeriod = function( ts ){
              if( URL_PARAM.app_id != undefined || URL_PARAM.ip != undefined || URL_PARAM.remote != undefined )
                return false;

              for( var t in status_db.probeStatus )
                  if( status_db.probeStatus[t].start <= ts && ts <= status_db.probeStatus[t].last_update )
                      return true;
              return false;
            }

            var createZeroPoint = function( ts, true_zero ){
                var zero = {};
                zero[ time_id ] = ts;

                var default_value = null;

                if( true_zero === true || inActivePeriod( ts ) )
                    default_value = 0;

                for( var c in cols )
                    zero[ cols[c].id ] = default_value;

                zero.DTT = default_value;
                zero.ART = default_value;

                return zero;
            }

            //add first element if need
            if( data.length == 0 || start_time < (data[0][ time_id ] - period_sampling) )
                data.unshift( createZeroPoint( start_time ) );

            //add last element if need
            if( data.length == 0 || end_time > (data[ data.length - 1 ][ time_id ] + period_sampling ) )
                data.push( createZeroPoint( end_time ) );

            var len    = data.length;
            var arr    = [];
            var lastTS = start_time;

            var last_exist = false;

            while( lastTS <= end_time ){
                lastTS += period_sampling;

                var existPoint = false;
                for (var i = 0; i < len; i++) {
                    var ts = data[i][time_id];

                    if( lastTS - period_sampling < ts && ts <= lastTS){
                        existPoint = true;
                        arr.push( data[i] );
                    }
                }

                if ( !existPoint ){
                  //there exist a point just before
                  if( last_exist )
                    arr.push( createZeroPoint( lastTS, true ) );
                  else
                    arr.push( createZeroPoint( lastTS ) );
                }
                else if( last_exist == false && arr.length > 1 ){
                  //update the precedent point to zero
                  var msg = arr[ arr.length - 1 - 1 ];
                  for( var k in msg )
                    if( msg[k] === null )
                      msg[k] = 0;
                }

                last_exist = existPoint;
            }


            return arr;
        });//end new Database
        //this is called each time database is reloaded to update parameters of database
        database.updateParameter = function( _old_param ){
          //mongoDB aggregate
          var group = { _id : {} };

          [ COL.TIMESTAMP.id ].forEach( function( el, index){
            group["_id"][ el ] = "$" + el;
          } );
          [ COL.DATA_VOLUME.id, COL.ACTIVE_FLOWS.id, COL.PACKET_COUNT.id, COL.PAYLOAD_VOLUME.id,
            COL.DL_RETRANSMISSION.id, COL.UL_RETRANSMISSION.id,
            COL.HANDSHAKE_TIME.id, COL.APP_RESPONSE_TIME.id, COL.DATA_TRANSFER_TIME.id,
          ].forEach( function( el, index){
            group[ el ] = {"$sum" : "$" + el};
          });
          [ COL.TIMESTAMP.id ].forEach( function( el, index){
            group[ el ] = {"$last" : "$"+ el};
          } );

          var $match = {};
          //timestamp
          $match[ COL.TIMESTAMP.id ] = {$gte: status_db.time.begin, $lte: status_db.time.end };
          //only IP (session report)
          $match[ COL.FORMAT_ID.id ] = MMTDrop.constants.CsvFormat.STATS_FORMAT;
          $match.isGen  = false;
          //only on TCP: ETH.VLAN?.IP?.*.TCP
          $match[ COL.APP_PATH.id ] = APP_PATH_REGEX;

          //load data corresponding to the selected app
          var probe_id  = URL_PARAM.probe_id;
          if( probe_id != undefined )
            $match[ COL.PROBE_ID.id ] = parseInt( probe_id );


          if( URL_PARAM.app_id() )
              $match[ COL.APP_ID.id] = URL_PARAM.app_id();
          if( URL_PARAM.ip )
              $match[ COL.IP_SRC.id] = URL_PARAM.ip;
          if( URL_PARAM.remote )
            $match[ COL.IP_DST.id ] = URL_PARAM.remote;


          return {query : [{"$match": $match},{"$group" : group}]};
        };//end database.updateParameter

        //line chart on the top
        var cLine = MMTDrop.chartFactory.createTimeline({
            getData: {
                getDataFn: function (db) {
                    var cols = [ COL.TIMESTAMP,
                                {id: COL.HANDSHAKE_TIME.id     , label: "Network Rountrip Time (NRT)" , type: "area-stack"},
                                {id: COL.APP_RESPONSE_TIME.id  , label: "App Response Time (ART)"     , type: "area-stack"},
                                {id: COL.DATA_TRANSFER_TIME.id , label: "Data Transfer Time (DTT)"    , type: "area-stack"},
                                //label: "Data Rate" must be sync with axes: {"Data Rate": "y2"}
                                {id: COL.DATA_VOLUME.id        , label: "Data Rate"                   , type: "line"},
                                //{id: COL.UL_RETRANSMISSION.id  , label: "Retransmission Rate"         , type: "line"}
                               ];
                    var data  = db.data();

                    var get_number = function( v ){
                      if( v == null || isNaN( v )) return -1;
                      return v;
                    }

                    //calculate the avg of time 
                    var length = 0, total  = 0, val;
                    for( var i=0; i<data.length; i++ ){
                      val = get_number( data[i][ COL.HANDSHAKE_TIME.id ] ) 
                              + get_number( data[i][ COL.DATA_TRANSFER_TIME.id ] ) 
                              + get_number( data[i][ COL.APP_RESPONSE_TIME.id ] );
                      //val = -3
                      if( val >= 0 ){
                        total  += val;
                        length ++;
                      }
                    }
                    total = Math.round(total/length);
                    window._EURT = total;
                    return {
                        data    : data,
                        columns : cols,
                        ylabel  : "Time (ms)",
                        height  : $( document ).width() > 1600 ? 270 : 250,
                        chart   : {
                          grid: {
                            y: {
                              lines : [
                                //granularity/average
                                {value: total, text: total + " ms/flow", position: 'start'}
                              ]
                            }
                          }
                        }
                    };
                }
            },

            //c3js options
            chart: {
                padding:{
                    top: 20,
                },
                data:{
                    type: "line",
                    axes:{
                        "Data Rate": "y2"
                    },
                    onclick: function( d, element ){
                        loadDetail( d.x.getTime() );
                    },
                    selection: {
                      enabled: true,
                      multiple: false
                    },
                },
                color: {
                    pattern: ['violet', 'orange', 'DeepSkyBlue', 'red']
                },
                grid: {
                    x: {
                        show: false
                    },
                    y: {
                      lines : [
                        //granularity line
                        {value: 100000, text: "10000 ms", position: 'start'}
                      ]
                    },
                },
                axis: {
                    x: {
                        tick: {
                            format: _this.formatTime,
                        }
                    },
                    y: {
                          tick:{
                              //override the default format
                              format: function( v ){
                                  if( v < 0 ) return 0;
                                  return  MMTDrop.tools.formatDataVolume(v);
                              }
                          },
                          min: 0
                    },
                    y2: {
                        show : true,
                        label: {
                            text: "Data Rate (bps)",
                            position: "outer"
                        },
                        tick: {
                            count: 5,
                            format: function( v ){
                                if( v < 0 ) return 0;
                                return MMTDrop.tools.formatDataVolume( v );
                            }
                        },
                        min: 0,
                        padding: {
                          top: 10,
                          bottom: 2
                        },
                    }
                },
                zoom: {
                    enabled: false,
                    rescale: true
                },
                tooltip:{
                    format: {
                        title:  _this.formatTime
                    }
                },
            },
        });

        //show tooltip when user moves mouse over one row off cTable
        window._showCLineTooltip = function ( time ){
            if( cLine )
                cLine.chart.tooltip.show( {x: time} );
        }
        window._hideCLineTooltip = function ( ){
            if( cLine )
                cLine.chart.tooltip.hide();
        }

        //detailled table on the bottom
        var cTable = MMTDrop.chartFactory.createTable({
            getData: {
                getDataFn: function (db) {
                    var cols = [ {id: 0, label:""},
                                {id: COL.TIMESTAMP.id            , label: "Time"            , align: "left"},
                                {id: COL.HANDSHAKE_TIME.id       , label: "NRT (ms/flow)"   , align: "right"},
                                {id: COL.APP_RESPONSE_TIME.id    , label: "ART (ms/trans.)" , align: "right"},
                                {id: COL.DATA_TRANSFER_TIME.id   , label: "DTT (ms/flow)"   , align: "right"},
                                
                                {id: COL.ACTIVE_FLOWS.id         , label: "#Flows"          , align: "right"},
                                {id: COL.PACKET_COUNT.id         , label: "Pkt Rate (pps)"  , align: "right"},
                                {id: "retransmission"            , label: "%Retrans."       , align: "right"},
                                {id: COL.DATA_VOLUME.id          , label: "Data Rate (bps)" , align: "right"},
                                {id: "packet_size"               , label: "Pkt Size (B)"    , align: "right"},
                                {id: COL.PAYLOAD_VOLUME.id       , label: "%Payload"        , align: "right"},
                               ];
                    var data = db.data();

                    var arr  = [];
                    var index = 0;
                    for( var i=0; i<data.length; i++ ){
                        var msg = data[i];
                        if( msg[0] == undefined )
                            continue;
                        //user can see in detail if this row has data
                        if( !( msg[ COL.DATA_VOLUME.id ] > 0 ))
                          continue;

                        msg[0] = ++index;

                        //this happens when cTable is drawn >= 2 times
                        if( msg.__formated === true ) continue;

                        var time = msg[ COL.TIMESTAMP.id ];

                        msg[ COL.TIMESTAMP.id ] = _this.formatTime( new Date( time ) );
                        var t2                  = _this.formatTime( new Date( time + fPeriod.getDistanceBetweenToSamples() * 1000 - 1000) );

                        if( t2.localeCompare( msg[ COL.TIMESTAMP.id ] ) != 0 )
                            t2 = msg[ COL.TIMESTAMP.id ] + " 	&rarr; " + t2;

                        msg[ COL.TIMESTAMP.id ] = '<a data-timestamp='+ time +' onclick="loadDetail('+ time +')">' + t2 + '</a>';

                        //DATA_VOLUME represents bandwith bps => need to divide by 8 to get bytes
                        msg["packet_size"] = _this.divide(msg[ COL.DATA_VOLUME.id ], msg[ COL.PACKET_COUNT.id ] * 8).toFixed(2);
                        msg[ "retransmission" ]    = _this.divide( (msg[ COL.UL_RETRANSMISSION.id ] + msg[ COL.DL_RETRANSMISSION.id ])*100, msg[COL.PACKET_COUNT.id]);
                        msg[ COL.DATA_VOLUME.id ]  = MMTDrop.tools.formatDataVolume( msg[ COL.DATA_VOLUME.id ] );
                        msg[ COL.PACKET_COUNT.id ] = MMTDrop.tools.formatDataVolume( msg[ COL.PACKET_COUNT.id ] );
                        //% payload
                        msg[ COL.PAYLOAD_VOLUME.id ]  += "%";
                        //% Retransmision
                        msg[ "retransmission" ]      += "%";
                        msg.__formated = true;

                        arr.push( msg );
                    }
                    return {
                        data    : arr,
                        columns : cols
                    };
                }
            },
            chart:{
                "order": [0, "asc"],
                dom: "<'tbl-resp-time-report' t><'row'<'col-sm-3'i><'col-sm-9'p>>",
            },
            bgPercentage:{
                table : ".tbl-resp-time-report",
                column: [9,12], //index of column, start from 1
                css   : "bg-img-1-red-pixel",
            },
            afterEachRender: function (_chart) {
                // Add event listener for opening and closing details
                _chart.chart.on('mouseover', 'tbody tr[role=row]', function () {
                    var ts  = $(this).find('a').data("timestamp");
                    if ( ts )
                        _showCLineTooltip( ts );
                    return false;
                });

                _chart.chart.on('mouseout', 'tbody', function () {
                    _hideCLineTooltip()
                    return false;
                });
            },
        });

        var report = new MMTDrop.Report(
            // title
            null,
            database,
            // filers
					[fApp],
            // charts
					[
            {
                charts: [cLine],
                width: 12
            },
            {
                charts: [cTable],
                width: 12
            },
					 ],
          [{object: cLine},{object: cTable}]
        );

        return report;
    },
    createSlowestAppsReport: function (fPeriod ){
      return this.createSlowestUsersReport( fPeriod, MMTDrop.constants.StatsColumn.APP_ID.id );
    },
    createSlowestRemotesReport: function (fPeriod ){
      return this.createSlowestUsersReport( fPeriod, MMTDrop.constants.StatsColumn.IP_DST.id );
    },
    createSlowestLocalsReport: function (fPeriod ){
       return this.createSlowestUsersReport( fPeriod, MMTDrop.constants.StatsColumn.IP_SRC.id );
     },
    createSlowestUsersReport: function (fPeriod, col_id) {
       var _this = this;
       var COL   = MMTDrop.constants.StatsColumn;
       var HTTP  = MMTDrop.constants.HttpStatsColumn;
       var FTP   = MMTDrop.constants.FtpStatsColumn;
       if( col_id == undefined )
          col_id = COL.IP_SRC.id;
       var is_app = (col_id == COL.APP_ID.id);



       var database = new MMTDrop.Database({collection: "data_session", action: "aggregate", raw: true, no_override_when_reload: true, period_groupby: fPeriod.selectedOption().id });
       //this is called each time database is reloaded to update parameters of database
       database.updateParameter = function( _old_param ){
          //mongoDB aggregate
          var $group = { _id : {} };

          [ col_id ].forEach( function( el, index){
             $group["_id"][ el ] = "$" + el;
          } );

          [  COL.ACTIVE_FLOWS.id,
             COL.HANDSHAKE_TIME.id, COL.APP_RESPONSE_TIME.id, COL.DATA_TRANSFER_TIME.id
             ].forEach( function( el, index){
                $group[ el ] = {"$sum" : "$" + el};
                //group._total["$sum"].push( "$" + el );
             });
          [ col_id ].forEach( function( el, index){
             $group[ el ] = {"$first" : "$"+ el};
          } );

          var $match = {} ;
          //timestamp
          $match[ COL.TIMESTAMP.id ] = {$gte: status_db.time.begin, $lte: status_db.time.end };
          //query on data_app ==> selection only real applications/protocols
          $match.isGen = false;
          //only IP (session report)
          $match[ COL.FORMAT_ID.id ] = MMTDrop.constants.CsvFormat.STATS_FORMAT;
          //select only APP or IP that contains APPs on the top of tcp
          $match[ COL.APP_PATH.id ]  = APP_PATH_REGEX;

          if( URL_PARAM.app_id() )
             $match[ COL.APP_ID.id ] = URL_PARAM.app_id();
          if( URL_PARAM.ip )
             $match[ COL.IP_SRC.id ] = URL_PARAM.ip;
          if( URL_PARAM.remote )
             $match[ COL.IP_DST.id ] = URL_PARAM.remote;

          //load data corresponding to the selected app
          var probe_id   = URL_PARAM.probe_id;
          if( probe_id != undefined )
             $match[ COL.PROBE_ID.id ] = parseInt( probe_id );

          return { query : [{"$match": $match},{"$group" : $group}] };
       }//end database.updateParameter

       //is_trans : show only transactions
       function createBar( is_trans ){
          if( is_trans == undefined ) is_trans = false;

          return MMTDrop.chartFactory.createBar({
             getData: {
                getDataFn: function (db) {
                   var data = db.data();

                   var divide = function( a, b ){
                      if( a == null || isNaN( a ) || b == null || isNaN( b ) || b == 0)
                         return 0;
                      return a/b;
                   }

                   for( var i in data ){
                      var v = 1000; // * 1000  to get milliseconds
                      if( data[i][ COL.ACTIVE_FLOWS.id ] != 0 )
                         v *= data[i][ COL.ACTIVE_FLOWS.id ];
                      data[i][ COL.HANDSHAKE_TIME.id ]     =  divide( data[i][ COL.HANDSHAKE_TIME.id ], v);
                      data[i][ COL.DATA_TRANSFER_TIME.id ] =  divide( data[i][ COL.DATA_TRANSFER_TIME.id ], v);
                      data[i][ COL.APP_RESPONSE_TIME.id ]  =  divide( data[i][ COL.APP_RESPONSE_TIME.id ], v);


                      data[i]._total = data[i][ COL.HANDSHAKE_TIME.id ] 
                                     + data[i][ COL.APP_RESPONSE_TIME.id ] 
                                     + data[i][ COL.DATA_TRANSFER_TIME.id ];
                   }

                   //get top 8
                   //sort by DESC of #Trans
                   data.sort( function( a, b ){
                      var val = b._total - a._total;
                      
                      if( val == 0 )
                         val = b[ COL.ACTIVE_FLOWS.id ] - a[ COL.ACTIVE_FLOWS.id ];
                      
                      return val;
                   });

                   var obj = [
                      ["RTT"],
                      ["ART"],
                      ["DTT"],
                      ];
                   if( is_trans )
                      obj = [["#Flows"]];

                   var groups = [];
                   for( var i in obj )
                      groups.push( obj[i][0]);


                   var ips = [];
                   for( var i=0; i<8; i++ ){
                      var msg = data[i];
                      var label = "";
                      if( is_trans )
                         ips.push( "");
                      else{
                         if( is_app )
                            ips.push( msg == undefined? "" : MMTDrop.constants.getProtocolNameFromID( msg[ col_id ] ));
                         else
                            ips.push( msg == undefined? "" : msg[ col_id ] );
                      }

                      if( is_trans ){
                         obj[0].push( msg == undefined? 0 : - msg[ COL.ACTIVE_FLOWS.id ] );
                      }else{
                         obj[0].push( msg == undefined? 0 : msg[ COL.HANDSHAKE_TIME.id ] );
                         obj[1].push( msg == undefined? 0 : msg[ COL.APP_RESPONSE_TIME.id ] );
                         obj[2].push( msg == undefined? 0 : msg[ COL.DATA_TRANSFER_TIME.id ] );
                      }
                   }
                   var cols = [];
                   for( var i in ips )
                      cols.push( {id: i, label: ips[i]} );


                   return {
                      data   : obj,
                      columns: cols,
                      chart  : {
                         data :{
                            groups: [groups]
                         },
                         axis : {
                            x  : {
                               categories : ips,
                            }
                         }
                      }
                   }
                }
             },
             chart: {
                //Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.
                onrendered: function(){
                   var _id = this.config.bindto;
                   //hide tick for transsitions bar chart
                   d3.select( _id ).select('.' + c3.chart.internal.fn.CLASS.axisX ).
                   selectAll(".tick").selectAll("line").style("visibility","hidden");

                   if( is_trans ){
                      d3.select( _id ).select('.' + c3.chart.internal.fn.CLASS.axisX )
                      // and translate it to the y = 0 position
                      .attr('transform', "translate(" + this.yMax + ",0)")
                      //hide Ox label
                      .selectAll("text").style('visibility', 'hidden')
                      ;

                      var $el = $( _id ).parents().filter(".col-md-5");
                      if( $el.length > 0 )
                         $el.css("padding-right", "0px");
                      //add class
                      d3.select( _id ).select(".c3-chart-bars").classed("mmt-c3-chart-bars-animation-inverted", true);
                   }else{

                      d3.select( _id ).select('.' + c3.chart.internal.fn.CLASS.axisX)
                      //set middle
                      .selectAll("text").style({
                         //'text-anchor' : 'middle',
                      })
                      .attr({"class" : "ahref", "fill": "#337ab7"})
                      .on("click", function(){
                         var cat = $(this).text();
                         MMTDrop.tools.gotoURL( MMTDrop.tools.getCurrentURL([], (is_app? "app=" : (col_id == COL.IP_SRC.id ? "ip=": "remote=")) + cat) )
                      })
                      // .on("mouseover", function(){
                      //   var text = $(this).text();
                      // })
                      //.selectAll("tspan").attr('x', -50)
                      ;

                      var $el = $( _id ).parents().filter(".col-md-7");
                      if( $el.length > 0 )
                         $el.css("padding-left", "0px");

                      d3.select( _id ).select(".c3-chart-bars").classed("mmt-c3-chart-bars-animation", true);
                   }
                },
                data: {
                   onclick: function (d, element) {
                      var cat = this.category( d.x );
                      MMTDrop.tools.gotoURL( MMTDrop.tools.getCurrentURL([], (is_app? "app=" : (col_id == COL.IP_SRC.id ? "ip=": "remote=")) + cat) )
                   },
                   selection: {
                      enabled     : true,
                      grouped     : true,
                      multiple    : false,
                      isselectable: function (d) {
                         window._tt = d;
                         return false;
                      }
                   },
                   onmouseover: function( d ){
                      //avoid 2 consecutif calls
                      var now = (new Date()).getTime();
                      if( this._lastCall_MouseOver == undefined )
                         this._lastCall_MouseOver = 0;
                      if( now - this._lastCall_MouseOver < 100 )
                         return;
                      this._lastCall_MouseOver = now;

                      var neighbour = this.parent._neighbour;
                      if( neighbour )
                         neighbour.chart.tooltip.show( {x: d.x} );
                   },
                   onmouseout: function( d ){
                      //avoid 2 consecutif calls
                      var now = (new Date()).getTime();
                      if( this._lastCall_MouseOut == undefined )
                         this._lastCall_MouseOut = 0;
                      if( now - this._lastCall_MouseOut < 100 )
                         return;
                      this._lastCall_MouseOut = now;

                      var neighbour = this.parent._neighbour;
                      if( neighbour )
                         neighbour.chart.tooltip.hide();
                   }
                },
                color: {
                   pattern: (is_trans ? ["#D35400"] : ['violet', 'orange', 'DeepSkyBlue'])
                },
                bar : {
                   width: 15,
                },
                axis: {
                   rotated: true,
                   y : {
                      //inverted: true,
                      tick : {
                         format: function( val ){
                            //number of flows
                            if( val < 0 )
                               return MMTDrop.tools.formatDataVolume( -val, true );
                            return MMTDrop.tools.formatDataVolume( val );
                         },
                         count: is_trans? 4 : 4
                      },
                      label: {
                         text    : is_trans? "flows" : "ms/flow",
                               position: is_trans? 'outter-left'   : 'outter-right'
                      },
                      padding: {
                         top: 0,
                         bottom: 0
                      },
                   },
                   x : {
                      //show : is_trans? false: true
                   }
                },
                grid: {
                   y: {
                      show : true,
                   }
                },
                padding: {
                   right: (is_trans ? 5: 30 ),
                   top  : 10
                },
                size:{
                   height: 250
                },
                legend : {
                   item: {
                      onclick: (is_trans ? function (id) {
                         //this function prevents hidding bars in Transaction
                      } : null)
                   }
                }
             },
          });
       }//end createBar;

       var cBar_time = createBar( ),
       cBar_tran = createBar( true );

       cBar_time._neighbour = cBar_tran;
       cBar_tran._neighbour = cBar_time;

       var report = new MMTDrop.Report(
             // title
             null,
             // database
             database,
             // filers
             [],
             // charts
             [{
                charts: [cBar_tran],
                width: 5
             },{
                charts: [cBar_time],
                width: 7
             }],
             //order of data flux
             [{object: cBar_tran}, {object: cBar_time}]
       );

       return report;
    },

    createDetailChart : function( ){
        var self    = this;
        var COL     = MMTDrop.constants.StatsColumn;
        var HTTP    = MMTDrop.constants.HttpStatsColumn;
        var SSL     = MMTDrop.constants.TlsStatsColumn;
        var RTP     = MMTDrop.constants.RtpStatsColumn;
        var FORMAT  = MMTDrop.constants.CsvFormat;
        var HISTORY = {};
        var openingRow;

        return MMTDrop.chartFactory.createTable({
            getData: {
                getDataFn: function (db) {
                    //reset
                    HISTORY    = {};
                    openingRow = {};

                    var col_key  = {id: COL.IP_DST.id,  label: "Remote Address" };
                    if( URL_PARAM.remote )
                      col_key  = {id: COL.APP_ID.id, label: "App/Proto"};

                    var columns = [
                      {id: COL.START_TIME.id, label: "Start Time"   , align:"left"},
                      {id: "LastUpdated"    , label: "Last Updated" , align:"left"},
                      col_key,
                      {id: "EURT"           , label: "EURT (ms)"    , align:"right"},
                                   ];

                    var colSum = [
                      {id: COL.HANDSHAKE_TIME.id      , label: "NRT (ms)"    , align:"right"},
                      {id: COL.APP_RESPONSE_TIME.id   , label: "ART (ms)"    , align:"right"},
                      {id: COL.DATA_TRANSFER_TIME.id  , label: "DTT (ms)"    , align:"right"},
                      {id: COL.ACTIVE_FLOWS.id        , label: "#Flows"      , align:"right"},
                      {id: COL.UL_DATA_VOLUME.id      , label: "Up. (B)"     , align:"right"},
                      {id: COL.DL_DATA_VOLUME.id      , label: "Down. (B)"   , align:"right"},
                      {id: COL.DATA_VOLUME.id         , label: "Total (B)"   , align:"right"},
                      {id: COL.PACKET_COUNT.id        , label: "#Packets"    , align:"right"},
                      //{id: "retransmission"           , label: "#Retrans."   , align:"right"},
                    ];

                    var data = db.data();

                    var arr = [];
                    var havingOther = false;
                    var updateIP2Name = function( obj, msg ){
                        if( obj.__needUpdateIP2Name == undefined )
                            return;

                        var host =  msg[ HTTP.HOSTNAME.id ];
                        if( host == undefined || host == "" )
                            host = msg[ SSL.SERVER_NAME.id ];
                        if( host != undefined && host != "" && host != obj[COL.IP_DST.id]){
                            obj[COL.IP_DST.id]  = obj[COL.IP_DST.id] + " (" + host  + ")" ;
                            delete( obj.__needUpdateIP2Name );
                        }
                    }

                    for( var i in data){
                        var msg = data[i];
                        var start_time  = msg[ COL.START_TIME.id ];
                        var last_update = msg[ COL.TIMESTAMP.id ];

                        if( last_update < start_time )
                            last_update = start_time;

                        var key_val = msg [ col_key.id ];
                        if( HISTORY[ key_val ] == undefined ){
                            HISTORY[ key_val ] = {
                                data  : {
                                    __key : key_val
                                },
                                detail: [],
                            };
                            //update
                            var obj = HISTORY[ key_val ].data;
                            obj[ col_key.id ] = msg[ col_key.id ];

                            //IP
                            if( col_key.id == COL.IP_DST.id ){
                                obj.__needUpdateIP2Name = true;
                                updateIP2Name( obj, msg );
                            }else
                                obj[ col_key.id ] =  MMTDrop.constants.getProtocolNameFromID( obj[ col_key.id ] );

                            obj[ COL.START_TIME.id ] = start_time;
                            obj[ "LastUpdated" ]     = last_update;
                            obj[ COL.TIMESTAMP.id ]  = msg[ COL.TIMESTAMP.id ];
                            for (var j in colSum )
                                obj[ colSum[j].id ] = msg[ colSum[j].id ];
                        }
                        else{
                            var obj = HISTORY[ key_val ].data;
                            if( col_key.id == COL.IP_DST.id )
                                updateIP2Name( obj, msg );

                            if( obj[ COL.START_TIME.id ] >  start_time ) obj[ COL.START_TIME.id ] = start_time;
                            if( obj[ "LastUpdated" ] < last_update )     obj[ "LastUpdated" ]     = last_update;

                            for (var j in colSum )
                                obj[ colSum[j].id ] += msg[ colSum[j].id ] ;

                        }
                    }

                    var arr = [];
                    for( var i in HISTORY )
                        arr.push( HISTORY[i].data );

                    arr.sort( function( a, b){
                        return b[ COL.DATA_VOLUME.id ] -  a[ COL.DATA_VOLUME.id ];
                    });

                    //format data
                    for( var i=0; i<arr.length; i++ ){
                        var obj = arr[i];
                        obj.index = i+1;

                        HISTORY[ i ] = HISTORY[ obj.__key ];

                        var param = obj[ col_key.id ];
                        var href  = "";
                        if( col_key.id == COL.IP_DST.id ){
                          if( param.indexOf("(") > 0 )
                            //152.163.50.2 (extmap.rub.ace.advertising.com)
                            param = "remote=" + param.substr(0, param.indexOf("(") - 1 );
                          else
                            param = "remote=" + param;

                          href = MMTDrop.tools.getCurrentURL([], param );
                          //goto detail if a local IP or an APP is selected
                          //if( URL_PARAM.app_id() != undefined && URL_PARAM.ip != undefined )
                          {
                            param  += "&ts=" + obj[ COL.TIMESTAMP.id ] + "&groupby=" + fPeriod.selectedOption().id;
                            if( window._EURT )
                              param += "&EURT=" + window._EURT;
                            href = "application/detail" + MMTDrop.tools.getQueryString([],param);
                          }
                        }else{
                          param = "app="+ param;

                          href = MMTDrop.tools.getCurrentURL([], param );
                          //goto detail if a local IP or an APP is selected
                          //if( URL_PARAM.remote != undefined && URL_PARAM.ip != undefined )
                          {
                            param  += "&ts=" + obj[ COL.TIMESTAMP.id ] + "&groupby=" + fPeriod.selectedOption().id;
                            if( window._EURT )
                              param += "&EURT=" + window._EURT;
                            href = "application/detail" + MMTDrop.tools.getQueryString([],param);
                          }
                        }


                        obj[ col_key.id ] = '<a href="'+ href +'">' + obj[ col_key.id ] + "</a>";

                        obj[ COL.START_TIME.id ]    = moment( obj[COL.START_TIME.id] ).format("YYYY/MM/DD HH:mm:ss");
                        obj[ "LastUpdated" ]        = moment( obj["LastUpdated"] )    .format("YYYY/MM/DD HH:mm:ss");
                        obj[ COL.UL_DATA_VOLUME.id] = MMTDrop.tools.formatDataVolume( obj[ COL.UL_DATA_VOLUME.id] );
                        obj[ COL.DL_DATA_VOLUME.id] = MMTDrop.tools.formatDataVolume( obj[ COL.DL_DATA_VOLUME.id] );
                        obj[ COL.DATA_VOLUME.id]    = MMTDrop.tools.formatDataVolume( obj[ COL.DATA_VOLUME.id]    );

                        //1000: micro second => milli second
                        obj[ COL.APP_RESPONSE_TIME.id ]  = self.divide( obj[ COL.APP_RESPONSE_TIME.id ] , obj[ COL.ACTIVE_FLOWS.id ] * 1000 );
                        obj[ COL.DATA_TRANSFER_TIME.id ] = self.divide( obj[ COL.DATA_TRANSFER_TIME.id ], obj[ COL.ACTIVE_FLOWS.id ] * 1000 );
                        obj[ COL.HANDSHAKE_TIME.id ]     = self.divide( obj[ COL.HANDSHAKE_TIME.id ]    , obj[ COL.ACTIVE_FLOWS.id ] * 1000 );

                        obj.EURT = self.divide( obj[ COL.HANDSHAKE_TIME.id ] + obj[ COL.APP_RESPONSE_TIME.id ] + obj[ COL.DATA_TRANSFER_TIME.id ], 1 );
                    }
                    columns = columns.concat( colSum  );
                    columns.unshift( {id: "index", label: ""});

                    return {
                        data: arr,
                        columns: columns
                    };
                }
            },
            chart: {
                //"scrollX": true,
                //"scrollY": true,
                dom: "<'row'<'col-sm-5'l><'col-sm-7'f>><t><'row'<'col-sm-3'i><'col-sm-9'p>>",
                deferRender: true,
                order: [[4, "desc"]]
            },
            afterEachRender: function (_chart) {
            }
        });
    },
}


var detail_db    = MMTDrop.databaseFactory.createStatDB({ collection: "data_session", action : "aggregate" });
var cTableDetail = ReportFactory.createDetailChart();

var last_call = {val: 0, ts: 0};
function loadDetail(timestamp) {
    var COL = MMTDrop.constants.StatsColumn;
    var HTTP = MMTDrop.constants.HttpStatsColumn;
    var FTP = MMTDrop.constants.FtpStatsColumn;
    var TLS = MMTDrop.constants.TlsStatsColumn;
    var RTP = MMTDrop.constants.RtpStatsColumn;

    if (timestamp == undefined)
        return;
    //avoid 2 consecutif calls (less than 2 seconds)
    var ts = (new Date()).getTime();
    if( last_call.val == timestamp && ts - last_call.ts < 2*1000 )
      return;
    last_call = { val: timestamp, ts: ts };

    //decide whether we can goto detail page without show the list
    if( URL_PARAM.app_id() != undefined
      && (URL_PARAM.ip != undefined || URL_PARAM.remote != undefined )){
      MMTDrop.tools.gotoURL("application/detail" + MMTDrop.tools.getQueryString([], "ts=" + timestamp + "&groupby=" + fPeriod.selectedOption().id));
      return;
    }

    var $match = {};
    //only reports comming from mmt-probe
    $match.isGen = false;
    $match[ COL.TIMESTAMP.id ] = timestamp;
    //only session protocols
    $match[COL.FORMAT_ID.id ] = MMTDrop.constants.CsvFormat.STATS_FORMAT;
    //only on TCP: ETH.VLAN?.IP?.*.TCP
    $match[ COL.APP_PATH.id ] = APP_PATH_REGEX;
    if (URL_PARAM.probe_id )
      $match[ COL.PROBE_ID.id ] = URL_PARAM.probe_id;
    if (URL_PARAM.app_id() )
      $match[ COL.APP_ID.id ] = URL_PARAM.app_id();
    if (URL_PARAM.ip )
      $match[ COL.IP_SRC.id ] = URL_PARAM.ip;
    if (URL_PARAM.remote )
      $match[ COL.IP_DST.id ] = URL_PARAM.remote;

    var col_id = COL.IP_DST.id;
    if( URL_PARAM.remote )//when an IP is selected ==> group by APP
      col_id = COL.APP_ID.id;

    var $group = {_id: {}};
    [ col_id ].forEach( function( el, index){
      $group["_id"][ el ] = "$" + el;
    } );

    [ COL.UL_DATA_VOLUME.id, COL.DL_DATA_VOLUME.id, COL.UL_PACKET_COUNT.id,
     COL.DL_PACKET_COUNT.id, COL.UL_PAYLOAD_VOLUME.id, COL.DL_PAYLOAD_VOLUME.id,
     COL.ACTIVE_FLOWS.id, COL.DATA_VOLUME.id, COL.PACKET_COUNT.id, COL.PAYLOAD_VOLUME.id,
     COL.HANDSHAKE_TIME.id, COL.APP_RESPONSE_TIME.id, COL.DATA_TRANSFER_TIME.id, 
     //COL.RTT_AVG_CLIENT.id, COL.RTT_AVG_SERVER.id,
     //COL.RTT_MAX_CLIENT.id, COL.RTT_MAX_SERVER.id,
     //COL.RTT_MIN_CLIENT.id, COL.RTT_MIN_SERVER.id,
     COL.DL_RETRANSMISSION.id,
     COL.UL_RETRANSMISSION.id,
     
     //, HTTP.TRANSACTIONS_COUNT.id
    ].forEach( function( el, index){
      $group[ el ] = {"$sum" : "$" + el};
      //group._total["$sum"].push( "$" + el );
    });
    [ COL.START_TIME.id, COL.APP_ID.id, COL.IP_DST.id, COL.START_TIME.id, HTTP.HOSTNAME.id, TLS.SERVER_NAME.id ].forEach( function( el, index){
      $group[ el ] = {"$first" : "$"+ el};
    } );
    [ COL.TIMESTAMP.id ].forEach( function( el, index){
      $group[ el ] = {"$last" : "$"+ el};
    } );

    detail_db.reload({
        query: [{$match: $match},{$group: $group}],
        period_groupby: fPeriod.selectedOption().id
    }, function(new_data, table) {
        table.attachTo(detail_db, false);
        table.renderTo("popupTable");
        var interval     = fPeriod.getDistanceBetweenToSamples() - 1;
        var time_str     = moment(timestamp).format("YYYY/MM/DD HH:mm:ss");
        var end_time_str = moment(timestamp + interval * 1000).format("YYYY/MM/DD HH:mm:ss");
        $("#detailItem").html('<strong>Interval: </strong> '
          + MMTDrop.tools.formatInterval( interval + 1 )
          + ' (from ' + time_str + ', to ' + end_time_str + ")");
        $("#modalWindow").modal();
    }, cTableDetail);


    if ($("#modalWindow").length === 0) {
        var modal = '<div class="modal modal-wide fade" tabindex="-1" role="dialog" aria-hidden="true" id="modalWindow">' +
            '<div class="modal-dialog">' +
            '<div class="modal-content" >' +
            '<div class="modal-header">' +
            '<button type="button" class="close" data-dismiss="modal" aria-label="Close">&times;</button>' +
            '<h4 class="modal-title">Detail</h4>' +
            '</div>' +
            '<div class="modal-body code-json">' +
            '<div id="detailItem"/>' +
            '<div id="popupTable"/>' +
            '</div>' +
            '</div></div></div>';

        $("body").append($(modal));
    }
}

//show hierarchy URL parameters on toolbar
$( breadcrumbs.loadDataFromURL );
